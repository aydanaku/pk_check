print("Определение термину 'наследование'")
a = open("nasledovanie.txt", mode='a+', encoding="utf-8")
a.write('Наследование позволяет создавать новый класс на основе уже существующего класса. Наряду с инкапсуляцией наследование является одним из краеугольных камней объектно-ориентированного дизайна.')
a.close()
print(70*'-')

print("Определение термину 'инкапсуляция'")
b = open("inkapstulyaciya.txt", mode='a+', encoding="utf-8")
b.write('Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным). Инкапсуляция делает некоторые из компонент доступными только внутри класса. Инкапсуляция в Python работает лишь на уровне соглашения между программистами о том, какие атрибуты являются общедоступными, а какие — внутренними.\n Модификаторы доступа в Python используются для модификации области видимости переменных по умолчанию. Есть три типа модификаторов доступов в Python ООП:\n 1)публичный — public;\n 2)приватный — private;\n 3)защищенный — protected.')
b.close()
print(70*'-')

print("Определение термину 'полиморфизм'")
c = open("polimorfizm.txt", mode='a+', encoding="utf-8")
c.write('Полиморфизм — очень важная идея в программировании. Она заключается в использовании единственной сущности(метод, оператор или объект) для представления различных типов в различных сценариях использования.')
c.close()
print(70*'-')

print("Определение термину 'абстракция'")
d = open("abstrakciya.txt", mode='a+', encoding="utf-8")
d.write('Абстракция позволяет нам не думать о внутренней реализации, когда мы работаем с элементам, предоставляемыми ею. То есть мы отделяем место, где данные используются, от места, где они создаются.')
d.close()
print(70*'-')

print("Определение термину 'композиция'")
e = open("kompoziciya.txt", mode='a+', encoding="utf-8")
e.write('Композиция — это концепция, которая моделирует отношения. Она позволяет создавать сложные типы, комбинируя объекты других типов. Это означает, что класс Composite может содержать объект другого класса Component.')
e.close()
print(70*'-')

print("Определение термину 'итератор'")
f = open("iterator.txt", mode='a+', encoding="utf-8")
f.write('Итератор - это объект, который возвращает свои элементы по одному за раз. С точки зрения Python - это любой объект, у которого есть метод __next__ . Этот метод возвращает следующий элемент, если он есть, или возвращает исключение StopIteration, когда элементы закончились.')
f.close()
print(70*'-')

print("Определение термину 'генератор'")
g = open("generator.txt", mode='a+', encoding="utf-8")
g.write('Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов. Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение прерывается. Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.\n В отличие от других типов итераторов, объекты-генераторы могут быть пройдены только один раз.')
g.close()
print(70*'-')

print("Что такое 'метаклассы'? Что такое 'метапрограммирование'")
h = open("metaclass.txt", mode='a+', encoding="utf-8")
h.write('Метаклассы – это такие классы, экземпляры которых сами являются классами. Подобно тому, как «обычный» класс определяет поведение экземпляров класса, метакласс определяет и поведение классов, и поведение их экземпляров.\n Метапрограммирование — это просто написание кода, который работает с метаклассами и схожие методики изменения кода на заднем плане.')
h.close()
print(70*'-')

print("Что такое 'миксины'?")
i = open("mixins.txt", mode='a+', encoding="utf-8")
i.write('В Python так называемые миксины — это классы, которые живут в обычном дереве наследования, но они остаются небольшими, чтобы избежать создания иерархий, которые слишком сложны для понимания программистом. В частности, миксины не должны иметь общих предков, кроме объекта, с другими родительскими классами.\n Миксин - это особый вид множественного наследования. Существуют две основные ситуации, в которых используются миксины:\n 1)Вы хотите предоставить много дополнительных функций для класса.\n 2)Вы хотите использовать одну особенность во множестве разных классов.')
i.close()
print(70*'-')

print("Как создать экземпляр класса (объект)?")
j = open("createclass.txt", mode='a+', encoding="utf-8")
j.write('Чтобы создать экземпляры классов, нужно вызвать класс с использованием его имени и передать аргументы, которые принимает метод __init__.')
j.close()
print(70*'-')

print("В чем основное отличие двух следующих вариантов кода?")
k = open("differenceofcodes.txt", mode='a+', encoding="utf-8")
k.write('Код 1: lst = [x for x in range(100000000000000000000000000000000000000000)]\n Код 2: gnr = (x for x in range(100000000000000000000000000000000000000000))\n ОТВЕТ: При использовании функции print():\n 1) первый код создаст список из все чисел от 1 до 100000000000000000000000000000000000000000;\n 2) второй код - результат "<generator object <genexpr> at 0x0060B4C0>", т.е. тип/класс объекта.')
k.close()
print(70*'-')